/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/vrp/v3": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Vehicle Routing Problem Result
         * @description Return the optimization result in json format.
         */
        get: operations["vrp_result"];
        put?: never;
        /**
         * Vehicle Routing Problem
         * @description Solve different types of vehicle routing problem (multi-vehicle route optimization), returns a `job_id` where you can check the job status and retrieve the result.
         *
         */
        post: operations["vrp"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tsp/v3": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Traveling Salesman Problem Result
         * @description Return the optimization result in json format.
         */
        get: operations["tsp_result"];
        put?: never;
        /**
         * Traveling Salesman Problem
         * @description Solve traveling salesman problem with various constraints (single-vehicle route optimization), returns a `job_id` where you can check the job status and retrieve the result.
         *
         */
        post: operations["tsp"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ondemand/v3": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * On-demand Result
         * @description Return the optimization result in json format.
         */
        get: operations["ondemand_result"];
        put?: never;
        /**
         * On-demand
         * @description Assign on-demand orders to existing drivers. Returns a `job_id` where you can check the job status and retrieve the result.
         *
         */
        post: operations["ondemand"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/replan/v3": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Replanning Result
         * @description Return the optimization result in json format.
         */
        get: operations["replan_result"];
        put?: never;
        /**
         * Replanning
         * @description Re-optimize an exiting route plan. Returns a `job_id` where you can check the job status and retrieve the result.
         *
         */
        post: operations["replan"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/route/v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Routing
         * @description Calculate route for a sequence of waypoints.
         *
         */
        post: operations["route"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/matrix/v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Matrix Routing Result
         * @description Return the Matrix Routing API result in units of meters and seconds. For more details regarding the format and error codes, please refer to the 200 response of the POST method.
         *
         */
        get: operations["matrix_result"];
        put?: never;
        /**
         * Matrix Routing
         * @description Calculate a matrix of travel distances and durations between a list of locations. Small requests having less than 40,000 elements will be executed synchronously, and http return code will be 200 if succeeded. Larger requests will be executed asynchronously, and http return code will be 202.
         *
         */
        post: operations["matrix"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/match/v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Map Matching
         * @description Calculate route from a list of GPS tracepoint.
         *
         */
        post: operations["match"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @description Specify the geographical information of this stop. */
        Geometry: {
            lat: number;
            lon: number;
            /**
             * @description Specifies the direction a vehicle may arrive at and depart from the order. If true, vehicle must stop at the closest curbside of this coordinate.
             *
             * @default false
             */
            curb: boolean;
        };
        ServiceNoConsumption: {
            /**
             * @description The amount of time driver spends at this order.
             * @default 0
             */
            duration: number;
            /** @description The size of the pickup. This property can also be specified in multiple dimensions (up to 4) with an array, such as weight, volume, and quantity.
             *      */
            pickup_quantities?: number | number[];
            /** @description The size of the delivery. This property can also be specified in multiple dimensions (up to 4) with an array, such as weight, volume, and quantity.
             *      */
            dropoff_quantities?: number | number[];
        };
        Service: {
            /**
             * @description The amount of time driver spends at this order.
             * @default 0
             */
            duration: number;
            /** @description The size of the pickup. This property can also be specified in multiple dimensions (up to 4) with an array, such as weight, volume, and quantity.
             *      */
            pickup_quantities?: number | number[];
            /** @description The size of the delivery. This property can also be specified in multiple dimensions (up to 4) with an array, such as weight, volume, and quantity.
             *      */
            dropoff_quantities?: number | number[];
            /** @description Consumption of vehicle's renewal capacity. This property can be either an integer or an array for multi-dimensions (up to 2) use case.
             *      */
            consumption?: number | number[];
        };
        TimeWindow: {
            /**
             * @description Time to visit this order no earlier than.
             * @default 0
             */
            start: number;
            /**
             * @description Time to visit this order no later than.
             * @default inf
             */
            end: number;
        };
        BaseOrder: {
            /** @description id of this order, has to be unique across all orders. */
            id?: string;
            geometry?: components["schemas"]["Geometry"];
            service?: components["schemas"]["Service"];
            time_window?: components["schemas"]["TimeWindow"];
            /**
             * @description The parking time spent at this order. Orders with same location and delivered by same vehicle at the same time will share the same parking time, i.e., only applied once on first order. If vehicle also has a parking time, it will be added to order's parking time.
             *
             * @default 0
             */
            parking_time: number;
            /**
             * @description The priority of this order to get assigned in whole optimization. Orders with higher priority (smaller number) will get assigned first when there's not enough vehicles.
             *
             * @default 3
             */
            assignment_priority: number;
            /** @description Prioritize the visiting sequence of this order in a route or group. Orders with higher priority (smaller number) will be visited earlier than orders with lower priority (bigger number). Default is `null`, which means no priority relationship.
             *      */
            sequence_priority?: number;
            /** @description If specified, `sequence_priority` will only take effect within orders having same group. Note that this parameter implies `cluster_label`, i.e., orders with same `sequence_group` will be put into same route (handled by same driver).
             *      */
            sequence_group?: string;
            /** @description id of the order that has paired pickup and delivery relationships with current order. E.g, pickup from current order and then deliver to the paired order or verse visa. Such order pairs are guaranteed to be assigned to the same route and has first pickup and then delivery topology.
             *      */
            paired_order?: string;
            /** @description id of the main order among all alternative orders. Only one of the alternative orders will be assigned. Can be used to defined multiple time windows, locations, etc.
             *      */
            alternative_order?: string;
            /** @description id of the immediate next order to be visited. */
            next_order?: string;
        };
        BaseVehicleProps: {
            /** @description Specify a speed factor for this vehicle (types). It will be applied to the distance matrix. Cannot be used together with `average_speed`.
             *      */
            speed_factor?: number;
            /** @description Specify an average speed for this vehicle (types). A speed factor will be derived and applied to the distance matrix. Cannot be used together with `speed_factor`.
             *      */
            average_speed?: number;
            /** @description Capacity of the vehicle. This property can also be specified in multiple dimensions (up to 4) with an array, such as weight, volume, and quantity. At least one dimension should be non-zero. */
            capacity?: number | number[];
            /**
             * @description Earliest time that this vehicle can be dispatched.
             * @default 0
             */
            dispatch_after: number;
            /**
             * @description Latest time that this vehicle must be dismissed.
             * @default inf
             */
            dismiss_before: number;
            /**
             * @description Parking time for this vehicle at order location.
             * @default 0
             */
            parking_time: number;
            /**
             * @description Maximum distance the vehicle can travel.
             * @default inf
             */
            max_distance: number;
            /**
             * @description Maximum duration the vehicle can travel for the workday.
             * @default inf
             */
            max_travel_time: number;
            /**
             * @description Maximum duration the vehicle can be on duty for the workday.
             * @default inf
             */
            max_total_time: number;
            /**
             * @description Maximum order time window violation the vehicle can have for the workday.
             * @default 0
             */
            max_late_time: number;
            /**
             * @description Maximum wait time allowed for a vehicle to wait before an order time window.
             * @default inf
             */
            max_wait_time: number;
        };
        VrpVehicleProps: {
            /** @description Specify a speed factor for this vehicle (types). It will be applied to the distance matrix. Cannot be used together with `average_speed`.
             *      */
            speed_factor?: number;
            /** @description Specify an average speed for this vehicle (types). A speed factor will be derived and applied to the distance matrix. Cannot be used together with `speed_factor`.
             *      */
            average_speed?: number;
            /** @description Capacity of the vehicle. This property can also be specified in multiple dimensions (up to 4) with an array, such as weight, volume, and quantity. At least one dimension should be non-zero. */
            capacity?: number | number[];
            /**
             * @description Earliest time that this vehicle can be dispatched.
             * @default 0
             */
            dispatch_after: number;
            /**
             * @description Latest time that this vehicle must be dismissed.
             * @default inf
             */
            dismiss_before: number;
            /**
             * @description Parking time for this vehicle at order location.
             * @default 0
             */
            parking_time: number;
            /**
             * @description Maximum distance the vehicle can travel.
             * @default inf
             */
            max_distance: number;
            /**
             * @description Maximum duration the vehicle can travel for the workday.
             * @default inf
             */
            max_travel_time: number;
            /**
             * @description Maximum duration the vehicle can be on duty for the workday.
             * @default inf
             */
            max_total_time: number;
            /**
             * @description Maximum order time window violation the vehicle can have for the workday.
             * @default 0
             */
            max_late_time: number;
            /**
             * @description Maximum wait time allowed for a vehicle to wait before an order time window.
             * @default inf
             */
            max_wait_time: number;
            /** @description Maximum size of accumulated pickup for the workday. */
            max_pickup_quantities?: number | number[];
            /** @description Maximum size of accumulated dropoff for the workday. */
            max_dropoff_quantities?: number | number[];
            /**
             * @description Maximum number of orders the vehicle can service per trip. Orders at same location that set `merge_calc_for_colocated` to `true` will only be counted once for the calculation. `Warning: lifting this constraint will significantly affect the solver performance.`
             *
             * @default 100
             */
            max_orders_per_route: number;
            /**
             * @description Minimum number of orders the vehicle can service per trip. Orders at same location that set `merge_calc_for_colocated` to `true` will only be counted once for the calculation. Note this is a soft constraint, solver will try hard to respect this constraint if possible, however, total cost may increase.
             *
             * @default 0
             */
            min_orders_per_route: number;
            /**
             * @description Maximum number of pickup orders the vehicle can service per trip. Orders at same location that set `merge_calc_for_colocated` to `true` will only be counted once for the calculation.
             *
             * @default inf
             */
            max_pickup_orders_per_route: number;
            /**
             * @description Maximum number of dropoff orders the vehicle can service per trip. Orders at same location that set `merge_calc_for_colocated` to `true` will only be counted once for the calculation.
             *
             * @default inf
             */
            max_dropoff_orders_per_route: number;
            /**
             * @description Maximum number of waypoints the vehicle can visit per trip. Waypoint is defined as unique (lat, lon, timepoint), including orders, depots, and renewals.
             *
             * @default inf
             */
            max_waypoints_per_route: number;
            /**
             * @description When set to true, automatically merge all orders at same location for the vehicle's `cost_per_order` and `max_[pickup|dropoff]_orders_per_route` calculation. In other words, orders at the same location will only be counted once.
             *
             * @default false
             */
            merge_colocated_in_calc: boolean;
            /**
             * @description Try to avoid wait time at each stop. May increase total travel time and distance.
             * @default false
             */
            avoid_wait_time: boolean;
        };
        RoutingProfile: {
            /** @description name of the routing profile. */
            name: string;
            /** @description Specify a base profile from the default list, `[bicycle, car]`. Different base profile has different routing restrictions.
             *      */
            base_profile: string;
            /** @description Specify an average speed for this routing profile. A speed factor will be derived and applied to the distance matrix. Cannot be used together with `speed_factor`.
             *      */
            average_speed?: number;
            /** @description Specify a speed factor for this routing profile. It will be applied to the distance matrix. Cannot be used together with `average_speed`.
             *      */
            speed_factor?: number;
        };
        PolygonRestriction: {
            /** @description id of this polygon. */
            id?: string;
            /** @description nodes of this polygon. */
            geometries?: {
                lat?: number;
                lon?: number;
            }[];
        };
        /** @description Specify units for all distance/duration based attribute values specified with different enums.
         *      */
        Units: {
            /**
             * @description Specify the distance units for all distance-based attribute values specified with different enums.
             *
             * @enum {string}
             */
            distance: "meter" | "kilometer" | "mile";
            /**
             * @description Specify the duration units for all duration-based attribute values specified with different enums.
             *
             * @enum {string}
             */
            duration: "second" | "minute" | "hour";
        };
        /**
         * @description Map provider for calculating OD matrix.
         * @default osm
         * @enum {string}
         */
        MapProviderAllowHere: "osm" | "here" | "tomtom";
        /**
         * @description Map provider for calculating OD matrix.
         * @default osm
         * @enum {string}
         */
        MapProviderNoHere: "osm" | "tomtom";
        VrpRequest: {
            /** @description Specify the orders the routes should visit. */
            orders: components["schemas"]["OrderVrp"][];
            /** @description Specify depots that vehicles depart from at the beginning of the workday. If not specified, route can start at any order.
             *      */
            start_depots?: components["schemas"]["Depot"][];
            /** @description Specify depots that vehicles return to at the end of the workday. If not specified, route ends at last assigned order.
             *      */
            end_depots?: components["schemas"]["Depot"][];
            /** @description Specify any rest periods, or breaks, for all the routes in a given vehicle routing problem.
             *      */
            breaks?: components["schemas"]["Break"][];
            /** @description Specify renewal locations for vehicles to renew capacities. */
            renewals?: components["schemas"]["Renewal"][];
            /** @description Specify groups of available vehicles. */
            vehicle_types: components["schemas"]["VehicleType"][];
            /**
             * @deprecated
             * @description ~~Specify customized routing profiles.~~ This feature is deprecated, please use `average_speed` or `speed_factor` in `vehicle_types`.
             *
             */
            routing_profiles?: components["schemas"]["RoutingProfile"][];
            /** @description Specify polygon restrictions for vehicles. */
            polygons?: components["schemas"]["PolygonRestriction"][];
            solver_parameters?: components["schemas"]["SolverParamsVrp"];
            units: components["schemas"]["Units"];
            /** @description Url to a custom distance matrix. If provided, we will use it instead of calculating
             *     ourselves. The matrix can be in either JSON or binary format. For JSON format, it should
             *     be an object containing `base_profile` - `car` or `bicycle`, and the associated matrix
             *     objects. Matrix object has two one-dimension arrays - `durations` and `distances`, which
             *     represent the estimated travel time and distance in row-major order. `durations` should
             *     be in seconds, `distance` should be in meters. When calculating the matrix, the sequence
             *     of input locations (or origins) should be start depots, end depots, then orders. Below
             *     is an example of a 4x4 matrix containing both `car` and `bicycle` profile,
             *     ```json
             *     {
             *       "car": {"durations": [0,81,80,0], "distances": [0,622,622,0]},
             *       "bicycle": {"durations": [0,158,157,0], "distances": [0,622,622,0]}
             *     }
             *     ```
             *
             *     For binary format, numbers should be stored in little-endian, where each matrix element
             *     consist of 2 4-bytes integers, representing the estimated travel time and distance. The
             *     units and sequence of input locations are same as JSON format. When having multiple
             *     `base_profile`, matrix values should be concatenated and sorted by the profile names.
             *     Using the JSON example, we would have `<bicycle><car>`.
             *
             *     Note when having large distance matrix, it is recommended to compress the data before
             *     uploading.
             *      */
            od_location?: string;
            /**
             * @description data type of the distance matrix provided in od_location
             * @default binary
             * @enum {string}
             */
            od_data_type: "binary" | "json";
            /** @description Define array of tags associated with this requests, which will be returned as-is in response.
             *      */
            user_tags?: string[];
        };
        TimeWindowVrp: {
            /**
             * @description Time to visit this order no earlier than.
             * @default 0
             */
            start: number;
            /**
             * @description Time to visit this order no later than.
             * @default inf
             */
            end: number;
            /**
             * @description Earliest possible time that vehicle visits this order shall depart from the start depot (e.g delivery perishable items).
             *
             * @default 0
             */
            depart_after: number;
            /**
             * @description Latest possible time that vehicle visits this order shall return to the end depot (e.g boarding planes before given time).
             *
             * @default inf
             */
            return_before: number;
        };
        TimeWindowBreak: {
            /** @description Time to take a break no earlier than. */
            start: number;
            /** @description Time to take a break no later than. */
            end: number;
        };
        OrderVrp: {
            /** @description id of this order, has to be unique across all orders. */
            id: string;
            geometry: components["schemas"]["Geometry"];
            service?: components["schemas"]["Service"];
            time_window?: components["schemas"]["TimeWindowVrp"];
            /**
             * @description The parking time spent at this order. Orders with same location and delivered by same vehicle at the same time will share the same parking time, i.e., only applied once on first order. If vehicle also has a parking time, it will be added to order's parking time.
             *
             * @default 0
             */
            parking_time: number;
            /**
             * @description The priority of this order to get assigned in whole optimization. Orders with higher priority (smaller number) will get assigned first when there's not enough vehicles.
             *
             * @default 3
             */
            assignment_priority: number;
            /** @description Prioritize the visiting sequence of this order in a route or group. Orders with higher priority (smaller number) will be visited earlier than orders with lower priority (bigger number). Default is `null`, which means no priority relationship.
             *      */
            sequence_priority?: number;
            /** @description If specified, `sequence_priority` will only take effect within orders having same group. Note that this parameter implies `cluster_label`, i.e., orders with same `sequence_group` will be put into same route (handled by same driver).
             *      */
            sequence_group?: string;
            /** @description id of the order that has paired pickup and delivery relationships with current order. E.g, pickup from current order and then deliver to the paired order or verse visa. Such order pairs are guaranteed to be assigned to the same route and has first pickup and then delivery topology.
             *      */
            paired_order?: string;
            /** @description id of the main order among all alternative orders. Only one of the alternative orders will be assigned. Can be used to defined multiple time windows, locations, etc.
             *      */
            alternative_order?: string;
            /** @description id of the immediate next order to be visited. */
            next_order?: string;
            /** @description Orders with same cluster label will be put into same route (handled by same driver).
             *      */
            cluster_label?: string;
            /** @description Mutually exclusive label, orders with different labels will not be put into same route. For example, you could segregate geographical zones with it.
             *      */
            mx_label?: string;
            /**
             * @deprecated
             * @description This parameter is deprecated and replace by `merge_calc_for_colocated`.
             *
             * @default true
             */
            is_unique: boolean;
            /**
             * @description Orders at same location that set this parameter to true will only be counted once for `cost_per_order` and `max_[pickup|dropoff]_orders_per_route` calculation.
             *
             * @default false
             */
            merge_calc_for_colocated: boolean;
            /** @description Array of vehicle capabilities that order requires. */
            capabilities?: string[];
            /** @description Specify a set of cost values associated with different metrics for this order. Each key represent a cost metric, and the corresponding value is the cost assigned to that metric, e.g., `{"weight": 10, "distance": 5}`. In `vehicle_types` item, you can then specify which cost metric should be used.
             *      */
            costs_by_metric?: {
                [key: string]: number | undefined;
            };
        };
        /** @description Specify where the vehicle departs from or ends at. If not specified, route can start or end at any order.
         *      */
        Depot: {
            /** @description id of this depot, has to be unique across all depots. */
            id: string;
            geometry: components["schemas"]["Geometry"];
            /** @default 0 */
            service_duration: number;
            time_window?: components["schemas"]["TimeWindow"];
        };
        Break: {
            /** @description e.g "lunch_break". */
            id: string;
            /** @description Specify the amount of time for this rest period or break. */
            duration: number;
            /** @description Specify the max consecutive working time without the break. */
            max_working_time?: number;
            time_window?: components["schemas"]["TimeWindowBreak"];
            /**
             * @description Indicates if the break is included in cost calculations.
             * @default true
             */
            is_paid: boolean;
        };
        Renewal: {
            /** @description id of this renewal location. */
            id: string;
            geometry: components["schemas"]["Geometry"];
            /**
             * @description Specify the amount of time for vehicle to renew its capacity at this location.
             * @default 0
             */
            duration: number;
        };
        /** @description Specify cost parameters for this vehicle type. */
        CostParamsVrp: {
            /**
             * @description cost for each completed order for this vehicle type.
             * @default 0
             */
            cost_per_order: number;
            /**
             * @description cost for this vehicle type to travel 1 unit time.
             * @default 1
             */
            cost_per_unit_time: number;
            /**
             * @description cost for this vehicle type to travel 1 unit distance.
             * @default 0
             */
            cost_per_unit_distance: number;
            /**
             * @description cost for each completed order for this vehicle type when in overorder.
             * @default 0
             */
            cost_per_overorder: number;
            /**
             * @description Specify how many orders when overorder starts. e.g., a vehicle type may have a different cost when delivering more than 20 orders.
             *
             * @default inf
             */
            overorder_start: number;
            /**
             * @description cost for this vehicle type to travel 1 unit time when in overtime.
             * @default 0
             */
            cost_per_unit_overtime: number;
            /**
             * @description Specify when overtime starts. e.g., a vehicle type may have 10 hours total time, and overtime starts from 8 hours.
             *
             * @default inf
             */
            overtime_start: number;
            /**
             * @description cost for this vehicle type to travel 1 unit distance when in overdistance.
             * @default 0
             */
            cost_per_unit_overdistance: number;
            /**
             * @description Specify when overdistance starts. e.g., a vehicle type incurs extra cost when travelling over 50 miles.
             *
             * @default inf
             */
            overdistance_start: number;
            /** @description Step costs based on distance ranges. The input is a list of 2-elements tuple: step and the associated cost. For example, assuming distance unit is km, then `[[5, 3], [10, 6]]` means 0-5 km is $3, and 5-10km is $6. Note that if the max step is less than vehicle's `max_distance`, we will assume max step to max distance has same cost of last defined step. Using above example, if vehicle's `max_distance` is 20km, then 10-20 km will be $6.
             *      */
            distance_step_costs?: unknown[][];
            /** @description Step costs based on duration ranges. The input has same requirements as `distance_step_costs`.
             *      */
            duration_step_costs?: unknown;
            /**
             * @description fixed cost to assign one vehicle with tasks.
             * @default 0
             */
            fixed_cost: number;
            /** @description Specify which cost metric from the `costs_by_metric` should be used for this vehicle type.
             *      */
            order_cost_metric?: string;
        };
        RenewalParamsService: {
            /** @description Service type renewal capacity. */
            capacity: number | number[];
            /** @description Consumption of vehicle's renewal capacity per order. This property can be either an integer or an array for multi-dimensions (up to 2) use case.
             *      */
            consumption_per_order?: number | number[];
        };
        RenewalParamsTravel: {
            /** @description Travel type renewal capacity. At least one of `consumption_per_unit_distance` and `consumption_per_unit_duration` must be provided.
             *      */
            capacity: number;
            /** @description Consumption of vehicle's renewal capacity per unit distance. */
            consumption_per_unit_distance?: number;
            /** @description Consumption of vehicle's renewal capacity per unit duration, travel time only, i.e., excluding wait time and service time.
             *      */
            consumption_per_unit_duration?: number;
        };
        VehicleType: {
            /** @description User input descriptor for this type of vehicle (e.g Minivan). */
            id: string;
            /**
             * @description Routing profile for the vehicle. Default profiles are `[car, bicycle]`, you can also use a custom profile defined in `routing_profiles`
             * @default car
             */
            profile: string;
            /**
             * @description Specify number of available vehicles for this vehicle type.
             * @default inf
             */
            count: number;
            /** @description Specify a speed factor for this vehicle (types). It will be applied to the distance matrix. Cannot be used together with `average_speed`.
             *      */
            speed_factor?: number;
            /** @description Specify an average speed for this vehicle (types). A speed factor will be derived and applied to the distance matrix. Cannot be used together with `speed_factor`.
             *      */
            average_speed?: number;
            /** @description Capacity of the vehicle. This property can also be specified in multiple dimensions (up to 4) with an array, such as weight, volume, and quantity. At least one dimension should be non-zero. */
            capacity?: number | number[];
            /**
             * @description Earliest time that this vehicle can be dispatched.
             * @default 0
             */
            dispatch_after: number;
            /**
             * @description Latest time that this vehicle must be dismissed.
             * @default inf
             */
            dismiss_before: number;
            /**
             * @description Parking time for this vehicle at order location.
             * @default 0
             */
            parking_time: number;
            /**
             * @description Maximum distance the vehicle can travel.
             * @default inf
             */
            max_distance: number;
            /**
             * @description Maximum duration the vehicle can travel for the workday.
             * @default inf
             */
            max_travel_time: number;
            /**
             * @description Maximum duration the vehicle can be on duty for the workday.
             * @default inf
             */
            max_total_time: number;
            /**
             * @description Maximum order time window violation the vehicle can have for the workday.
             * @default 0
             */
            max_late_time: number;
            /**
             * @description Maximum wait time allowed for a vehicle to wait before an order time window.
             * @default inf
             */
            max_wait_time: number;
            /** @description Maximum size of accumulated pickup for the workday. */
            max_pickup_quantities?: number | number[];
            /** @description Maximum size of accumulated dropoff for the workday. */
            max_dropoff_quantities?: number | number[];
            /**
             * @description Maximum number of orders the vehicle can service per trip. Orders at same location that set `merge_calc_for_colocated` to `true` will only be counted once for the calculation. `Warning: lifting this constraint will significantly affect the solver performance.`
             *
             * @default 100
             */
            max_orders_per_route: number;
            /**
             * @description Minimum number of orders the vehicle can service per trip. Orders at same location that set `merge_calc_for_colocated` to `true` will only be counted once for the calculation. Note this is a soft constraint, solver will try hard to respect this constraint if possible, however, total cost may increase.
             *
             * @default 0
             */
            min_orders_per_route: number;
            /**
             * @description Maximum number of pickup orders the vehicle can service per trip. Orders at same location that set `merge_calc_for_colocated` to `true` will only be counted once for the calculation.
             *
             * @default inf
             */
            max_pickup_orders_per_route: number;
            /**
             * @description Maximum number of dropoff orders the vehicle can service per trip. Orders at same location that set `merge_calc_for_colocated` to `true` will only be counted once for the calculation.
             *
             * @default inf
             */
            max_dropoff_orders_per_route: number;
            /**
             * @description Maximum number of waypoints the vehicle can visit per trip. Waypoint is defined as unique (lat, lon, timepoint), including orders, depots, and renewals.
             *
             * @default inf
             */
            max_waypoints_per_route: number;
            /**
             * @description When set to true, automatically merge all orders at same location for the vehicle's `cost_per_order` and `max_[pickup|dropoff]_orders_per_route` calculation. In other words, orders at the same location will only be counted once.
             *
             * @default false
             */
            merge_colocated_in_calc: boolean;
            /**
             * @description Try to avoid wait time at each stop. May increase total travel time and distance.
             * @default false
             */
            avoid_wait_time: boolean;
            /**
             * @description Allow this vehicle type to be dispatched again after returning to depot. In each dispatch, `capacity` and `max_orders_per_route` will be reset.
             *
             * @default false
             */
            multi_dispatch: boolean;
            /**
             * @deprecated
             * @description ~~If solver dispatchs this vehicle type, setting this value to `true` will dispatch all available vehicles.~~ This parameter is deprecated, please set `dispatch_strategy` to `all_if_selected` instead.
             *
             * @default false
             */
            use_all_vehicles: boolean;
            /**
             * @description Specify the dispatch strategy for this vehicle type. The default value is `auto`, where solver automatically determines how many vehicles to use from this type based on `cost_params`. If set to `all_if_selected`, solver will dispatch all vehicles of this type if selected. If set to `always_all`, solver will always prefer to dispatch all vehicles of this type, regardless of cost considerations.
             *
             * @default auto
             * @enum {string}
             */
            dispatch_strategy: "auto" | "all_if_selected" | "always_all";
            /** @description Specify start_depot id(s), solver will choose from the candidates for the vehicle to start at. If set to `any` (default), solver will automatically select the best one from `start_depots`. If set to `none`, vehicle will not start at a start depot, but instead start from one of the orders, which solver will automatically select the best one.
             *      */
            start_depot?: string | string[];
            /** @description Specify end_depot id(s), solver will choose from the candidates for the vehicle to return to. If set to `any` (default), solver will automatically select the best one from `end_depots`. If set to `none`, vehicle will not return to an end depot, but instead end at last order.
             *      */
            end_depot?: string | string[];
            /** @description Break_ids that defined in break items, e.g "lunch_break". */
            break_ids?: string[];
            /** @description Array of capabilities that vehicle has. */
            capabilities?: string[];
            /** @description Only assign orders inside the specified polygons to this vehicle type. */
            allowed_polygons?: string[];
            /** @description Only assign orders outside the specified polygons to this vehicle type. */
            disallowed_polygons?: string[];
            cost_params?: components["schemas"]["CostParamsVrp"];
            /** @description Renewals related parameters. */
            renewal_params?: components["schemas"]["RenewalParamsService"] | components["schemas"]["RenewalParamsTravel"];
        };
        SolverParamsVrp: {
            map_provider?: components["schemas"]["MapProviderAllowHere"];
            /**
             * @deprecated
             * @description ~~Specify which traffic type to use. Not available with OpenStreetMap.~~ This parameter is no longer used. Specify a `traffic_time` in the past will imply `historical`, while a time in the future will imply `predictive`.
             *
             * @enum {string}
             */
            traffic_type?: "historical" | "predictive";
            /** @description Specify the time point in ISO 8601 format for traffic query. For example, `2021-01-01T14:00:00-08:00` means 2021 Jan 1st, 2PM, UTC-08:00. Not available when `map_provider` is set to `osm` (OpenStreetMap). Required when `map_provider` is set to `tomtom` or `here`. */
            traffic_time?: string;
            /** @description Specify the maximum distance to snap unroutable locations to nearest road network.
             *      */
            snap_distance?: number;
            /**
             * @description Specify search level for optimization, from 0 to 2, default to 1. Setting to 0 will greatly reduce solver time but make solution quality worse. Setting to 2 will improve solution quality at the cost of increasing solver time.
             *
             * @default 1
             */
            search_level: number;
            /**
             * @description Specify clustering level for optimization, from 0 to 2, default to 0, which means reducing overall cost is the highest priority. Setting to 1 will greatly increase cluster quality while also trying to minimize overall cost increase. Setting to 2 will further increase cluster quality but without a guarantee how much overall cost may increase.
             *
             * @default 0
             */
            clustering_level: number;
            /** @default false */
            avoid_tolls: boolean;
            /**
             * @deprecated
             * @description ~~Further improve solution quality at the cost of increasing solver time.~~ This feature is deprecated, please use `search_level` instead.
             *
             * @default false
             */
            exhaustive_search: boolean;
            /**
             * @deprecated
             * @description ~~Further improve cluster quality at the cost of using more vehicles or increasing travel time.~~ This feature is deprecated, please use `clustering_level` instead.
             *
             * @default false
             */
            high_quality_cluster: boolean;
            /**
             * @description Balance routes between same vehicle type. May affect clustering quality and increase cost.
             *
             * @default false
             */
            balance_routes: boolean;
            /**
             * @description When set to `true`, `cluster_label` will become a soft constraint, which suggest (instead of forcing) the solver to put orders with same `cluster_label` into same route.
             *
             * @default false
             */
            soft_cluster_label: boolean;
            /** @description Capabilities are hard constraints by default. However, you can specify them here to be soft constraints, i.e., it can be dropped when no matching vehicle can be found.
             *      */
            soft_capabilities?: string[][];
            /**
             * @description Specify the renewal type, consumption will have different meanings depending on this value. For example, when set to `travel`, consumption is based on travel distance and duration. A common use case is EV charging, where the renewal capacity corresponds to the battery capacity, and consumption is based on travel distance. If set to `service`, consumption will occur on a per-order basis. A typical scenario is waste collection, where the vehicle will dump at renewal points when its capacity is fully consumed.
             *
             * @enum {string}
             */
            renewal_type?: "travel" | "service";
        };
        TspRequest: {
            /** @description Specify new orders to be assigned. */
            orders: components["schemas"]["OrderTsp"][];
            vehicle: components["schemas"]["VehicleTsp"];
            start_depot?: components["schemas"]["Depot"];
            end_depot?: components["schemas"]["Depot"];
            /** @description Specify any rest periods, or breaks, for all the routes in a given vehicle routing problem.
             *      */
            breaks?: components["schemas"]["Break"][];
            /** @description Specify renewal locations for vehicles to renew capacities. */
            renewals?: components["schemas"]["Renewal"][];
            /**
             * @deprecated
             * @description ~~Specify customized routing profile.~~ This feature is deprecated, please use `average_speed` or `speed_factor` in `vehicle`.
             *
             */
            routing_profile?: {
                /** @description name of the routing profile. */
                name: string;
                /** @description Specify a base profile from the default list, `[bicycle, car]`. Different base profile has different routing restrictions.
                 *      */
                base_profile: string;
                /** @description Specify an average speed for this routing profile. A speed factor will be derived and applied to the distance matrix. Cannot be used together with `speed_factor`.
                 *      */
                average_speed?: number;
                /** @description Specify a speed factor for this routing profile. It will be applied to the distance matrix. Cannot be used together with `average_speed`.
                 *      */
                speed_factor?: number;
            };
            solver_parameters?: components["schemas"]["SolverParamsTsp"];
            units: components["schemas"]["Units"];
            /** @description Define array of tags associated with this requests, which will be returned as-is in response.
             *      */
            user_tags?: string[];
        };
        OrderTsp: {
            /** @description id of this order, has to be unique across all orders. */
            id: string;
            geometry: components["schemas"]["Geometry"];
            service?: components["schemas"]["Service"];
            time_window?: components["schemas"]["TimeWindow"];
            /**
             * @description The parking time spent at this order. Orders with same location and delivered by same vehicle at the same time will share the same parking time, i.e., only applied once on first order. If vehicle also has a parking time, it will be added to order's parking time.
             *
             * @default 0
             */
            parking_time: number;
            /**
             * @description The priority of this order to get assigned in whole optimization. Orders with higher priority (smaller number) will get assigned first when there's not enough vehicles.
             *
             * @default 3
             */
            assignment_priority: number;
            /** @description Prioritize the visiting sequence of this order in a route or group. Orders with higher priority (smaller number) will be visited earlier than orders with lower priority (bigger number). Default is `null`, which means no priority relationship.
             *      */
            sequence_priority?: number;
            /** @description If specified, `sequence_priority` will only take effect within orders having same group. Note that this parameter implies `cluster_label`, i.e., orders with same `sequence_group` will be put into same route (handled by same driver).
             *      */
            sequence_group?: string;
            /** @description id of the order that has paired pickup and delivery relationships with current order. E.g, pickup from current order and then deliver to the paired order or verse visa. Such order pairs are guaranteed to be assigned to the same route and has first pickup and then delivery topology.
             *      */
            paired_order?: string;
            /** @description id of the main order among all alternative orders. Only one of the alternative orders will be assigned. Can be used to defined multiple time windows, locations, etc.
             *      */
            alternative_order?: string;
            /** @description id of the immediate next order to be visited. */
            next_order?: string;
        };
        /** @description Specify cost parameters for this vehicle type. */
        CostParamsTsp: {
            /**
             * @description cost for this vehicle type to travel 1 unit time.
             * @default 1
             */
            cost_per_unit_time: number;
            /**
             * @description cost for this vehicle type to travel 1 unit distance.
             * @default 0
             */
            cost_per_unit_distance: number;
        };
        /** @description Vehicle for this route. */
        VehicleTsp: {
            /** @description User input descriptor for this vehicle. */
            id: string;
            /**
             * @description Routing profile for the vehicle. Default profiles are `[car, bicycle]`, you can also use a custom profile defined in `routing_profiles`
             * @default car
             */
            profile: string;
            /** @description Specify a speed factor for this vehicle (types). It will be applied to the distance matrix. Cannot be used together with `average_speed`.
             *      */
            speed_factor?: number;
            /** @description Specify an average speed for this vehicle (types). A speed factor will be derived and applied to the distance matrix. Cannot be used together with `speed_factor`.
             *      */
            average_speed?: number;
            /** @description Capacity of the vehicle. This property can also be specified in multiple dimensions (up to 4) with an array, such as weight, volume, and quantity. At least one dimension should be non-zero. */
            capacity?: number | number[];
            /**
             * @description Earliest time that this vehicle can be dispatched.
             * @default 0
             */
            dispatch_after: number;
            /**
             * @description Latest time that this vehicle must be dismissed.
             * @default inf
             */
            dismiss_before: number;
            /**
             * @description Parking time for this vehicle at order location.
             * @default 0
             */
            parking_time: number;
            /**
             * @description Maximum distance the vehicle can travel.
             * @default inf
             */
            max_distance: number;
            /**
             * @description Maximum duration the vehicle can travel for the workday.
             * @default inf
             */
            max_travel_time: number;
            /**
             * @description Maximum duration the vehicle can be on duty for the workday.
             * @default inf
             */
            max_total_time: number;
            /**
             * @description Maximum order time window violation the vehicle can have for the workday.
             * @default 0
             */
            max_late_time: number;
            /**
             * @description Maximum wait time allowed for a vehicle to wait before an order time window.
             * @default inf
             */
            max_wait_time: number;
            /**
             * @description Try to avoid wait time at each stop. May increase total travel time and distance.
             * @default false
             */
            avoid_wait_time: boolean;
            cost_params?: components["schemas"]["CostParamsTsp"];
            /** @description Renewals related parameters. */
            renewal_params?: components["schemas"]["RenewalParamsService"] | components["schemas"]["RenewalParamsTravel"];
        };
        SolverParamsTsp: {
            map_provider?: components["schemas"]["MapProviderAllowHere"];
            /**
             * @deprecated
             * @description ~~Specify which traffic type to use. Not available with OpenStreetMap.~~ This parameter is no longer used. Specify a `traffic_time` in the past will imply `historical`, while a time in the future will imply `predictive`.
             *
             * @enum {string}
             */
            traffic_type?: "historical" | "predictive";
            /** @description Specify the time point in ISO 8601 format for traffic query. For example, `2021-01-01T14:00:00-08:00` means 2021 Jan 1st, 2PM, UTC-08:00. Not available when `map_provider` is set to `osm` (OpenStreetMap). Required when `map_provider` is set to `tomtom` or `here`. */
            traffic_time?: string;
            /** @description Specify the maximum distance to snap unroutable locations to nearest road network. */
            snap_distance?: number;
            /** @default false */
            avoid_tolls: boolean;
            /**
             * @description Specify the renewal type, consumption will have different meanings depending on this value. For example, when set to `travel`, consumption is based on travel distance and duration. A common use case is EV charging, where the renewal capacity corresponds to the battery capacity, and consumption is based on travel distance. If set to `service`, consumption will occur on a per-order basis. A typical scenario is waste collection, where the vehicle will dump at renewal points when its capacity is fully consumed.
             *
             * @enum {string}
             */
            renewal_type?: "travel" | "service";
        };
        OnDemandRequest: {
            /** @description Specify current routes that's already planned. */
            current_routes: components["schemas"]["CurrentRoute"][];
            /** @description Specify new orders to be assigned. */
            orders: components["schemas"]["OrderOnDemand"][];
            /**
             * @deprecated
             * @description ~~Specify customized routing profiles.~~ This feature is deprecated, please use `average_speed` or `speed_factor` in `current_routes.[].vehicle`.
             *
             */
            routing_profiles?: components["schemas"]["RoutingProfile"][];
            /** @description Specify polygon restrictions for vehicles. */
            polygons?: components["schemas"]["PolygonRestriction"][];
            solver_parameters?: components["schemas"]["SolverParamsOnDemand"];
            units: components["schemas"]["Units"];
            /** @description Define array of tags associated with this requests, which will be returned as-is in response.
             *      */
            user_tags?: string[];
        };
        OrderOnDemand: {
            /** @description id of this order, has to be unique across all orders. */
            id: string;
            geometry: components["schemas"]["Geometry"];
            service?: components["schemas"]["ServiceNoConsumption"];
            time_window?: components["schemas"]["TimeWindow"];
            /**
             * @description The parking time spent at this order. Orders with same location and delivered by same vehicle at the same time will share the same parking time, i.e., only applied once on first order. If vehicle also has a parking time, it will be added to order's parking time.
             *
             * @default 0
             */
            parking_time: number;
            /**
             * @description The priority of this order to get assigned in whole optimization. Orders with higher priority (smaller number) will get assigned first when there's not enough vehicles.
             *
             * @default 3
             */
            assignment_priority: number;
            /** @description Prioritize the visiting sequence of this order in a route or group. Orders with higher priority (smaller number) will be visited earlier than orders with lower priority (bigger number). Default is `null`, which means no priority relationship.
             *      */
            sequence_priority?: number;
            /** @description If specified, `sequence_priority` will only take effect within orders having same group. Note that this parameter implies `cluster_label`, i.e., orders with same `sequence_group` will be put into same route (handled by same driver).
             *      */
            sequence_group?: string;
            /** @description id of the order that has paired pickup and delivery relationships with current order. E.g, pickup from current order and then deliver to the paired order or verse visa. Such order pairs are guaranteed to be assigned to the same route and has first pickup and then delivery topology.
             *      */
            paired_order?: string;
            /** @description id of the main order among all alternative orders. Only one of the alternative orders will be assigned. Can be used to defined multiple time windows, locations, etc.
             *      */
            alternative_order?: string;
            /** @description id of the immediate next order to be visited. */
            next_order?: string;
            /** @description Orders with same cluster label will be put into same route (handled by same driver).
             *      */
            cluster_label?: string;
            /** @description Mutually exclusive label, orders with different labels will not be put into same route. For example, you could segregate geographical zones with it.
             *      */
            mx_label?: string;
            /**
             * @deprecated
             * @description This parameter is deprecated and replace by `merge_calc_for_colocated`.
             *
             * @default true
             */
            is_unique: boolean;
            /**
             * @description Orders at same location that set this parameter to true will only be counted once for `cost_per_order` and `max_[pickup|dropoff]_orders_per_route` calculation.
             *
             * @default false
             */
            merge_calc_for_colocated: boolean;
            /** @description Array of vehicle capabilities that order requires. */
            capabilities?: string[];
            /** @description Specify a set of cost values associated with different metrics for this order. Each key represent a cost metric, and the corresponding value is the cost assigned to that metric, e.g., `{"weight": 10, "distance": 5}`. In `vehicle_types` item, you can then specify which cost metric should be used.
             *      */
            costs_by_metric?: {
                [key: string]: number | undefined;
            };
            /** @description Array of vehicles not allowed to take this order. */
            disallowed_vehicles?: string[];
            /** @description Maximum distance from previous and next stop (excluding end depot) to assign this order.
             *      */
            max_adjacent_distance?: number;
        };
        CurrentRouteStop: {
            /** @description id of this order, has to be unique across all orders. */
            id: string;
            /**
             * @description Type of this stop.
             * @enum {string}
             */
            type: "order" | "start_depot" | "end_depot";
            /**
             * @description If false, solver is allowed to transfer this order to other vehicle.
             * @default true
             */
            lock_vehicle: boolean;
            geometry?: components["schemas"]["Geometry"];
            service?: components["schemas"]["ServiceNoConsumption"];
            time_window?: components["schemas"]["TimeWindow"];
            /**
             * @description The parking time spent at this order. Orders with same location and delivered by same vehicle at the same time will share the same parking time, i.e., only applied once on first order. If vehicle also has a parking time, it will be added to order's parking time.
             *
             * @default 0
             */
            parking_time: number;
            /**
             * @description The priority of this order to get assigned in whole optimization. Orders with higher priority (smaller number) will get assigned first when there's not enough vehicles.
             *
             * @default 3
             */
            assignment_priority: number;
            /** @description Prioritize the visiting sequence of this order in a route or group. Orders with higher priority (smaller number) will be visited earlier than orders with lower priority (bigger number). Default is `null`, which means no priority relationship.
             *      */
            sequence_priority?: number;
            /** @description If specified, `sequence_priority` will only take effect within orders having same group. Note that this parameter implies `cluster_label`, i.e., orders with same `sequence_group` will be put into same route (handled by same driver).
             *      */
            sequence_group?: string;
            /** @description id of the order that has paired pickup and delivery relationships with current order. E.g, pickup from current order and then deliver to the paired order or verse visa. Such order pairs are guaranteed to be assigned to the same route and has first pickup and then delivery topology.
             *      */
            paired_order?: string;
            /** @description id of the main order among all alternative orders. Only one of the alternative orders will be assigned. Can be used to defined multiple time windows, locations, etc.
             *      */
            alternative_order?: string;
            /** @description id of the immediate next order to be visited. */
            next_order?: string;
            /** @description Orders with same cluster label will be put into same route (handled by same driver).
             *      */
            cluster_label?: string;
            /** @description Mutually exclusive label, orders with different labels will not be put into same route. For example, you could segregate geographical zones with it.
             *      */
            mx_label?: string;
            /**
             * @deprecated
             * @description This parameter is deprecated and replace by `merge_calc_for_colocated`.
             *
             * @default true
             */
            is_unique: boolean;
            /**
             * @description Orders at same location that set this parameter to true will only be counted once for `cost_per_order` and `max_[pickup|dropoff]_orders_per_route` calculation.
             *
             * @default false
             */
            merge_calc_for_colocated: boolean;
            /** @description Array of vehicle capabilities that order requires. */
            capabilities?: string[];
            /** @description Specify a set of cost values associated with different metrics for this order. Each key represent a cost metric, and the corresponding value is the cost assigned to that metric, e.g., `{"weight": 10, "distance": 5}`. In `vehicle_types` item, you can then specify which cost metric should be used.
             *      */
            costs_by_metric?: {
                [key: string]: number | undefined;
            };
            /** @description Array of vehicles not allowed to take this order. */
            disallowed_vehicles?: string[];
            /** @description Maximum distance from previous and next stop (excluding end depot) to assign this order.
             *      */
            max_adjacent_distance?: number;
        };
        CurrentRouteBreak: {
            /** @description id of a break stop */
            id: string;
            /**
             * @description Type of this stop.
             * @enum {string}
             */
            type: "break";
            /** @description Specify the amount of time for this rest period or break. */
            duration: number;
            time_window: components["schemas"]["TimeWindowBreak"];
            /**
             * @description Indicates if the break is included in cost calculations.
             * @default true
             */
            is_paid: boolean;
        };
        CurrentRoute: {
            vehicle: components["schemas"]["VehicleOnDemand"];
            stops: (components["schemas"]["CurrentRouteStop"] | components["schemas"]["CurrentRouteBreak"])[];
            /**
             * @description Lock the visiting sequence of first N orders.
             * @default 0
             */
            lock_first_n_orders: number;
            /**
             * @description Assigning new orders should not increase the total distance more than this threshold.
             *
             * @default inf
             */
            max_incremental_distance: number;
            /**
             * @description If true and no orders are locked, this route can be optimized away.
             * @default false
             */
            is_reducible: boolean;
        };
        /** @description Specify cost parameters for this vehicle type. */
        CostParamsOnDemand: {
            /**
             * @description cost for each completed order for this vehicle type.
             * @default 0
             */
            cost_per_order: number;
            /**
             * @description cost for this vehicle type to travel 1 unit time.
             * @default 1
             */
            cost_per_unit_time: number;
            /**
             * @description cost for this vehicle type to travel 1 unit distance.
             * @default 0
             */
            cost_per_unit_distance: number;
            /** @description extra cost for this vehicle type to travel 1 unit time when in late time. */
            cost_per_unit_late_time?: number;
            /**
             * @description cost for each completed order for this vehicle type when in overorder.
             * @default 0
             */
            cost_per_overorder: number;
            /**
             * @description Specify how many orders when overorder starts. e.g., a vehicle type may have a different cost when delivering more than 20 orders.
             *
             * @default inf
             */
            overorder_start: number;
            /**
             * @description cost for this vehicle type to travel 1 unit time when in overtime.
             * @default 0
             */
            cost_per_unit_overtime: number;
            /**
             * @description Specify when overtime starts. e.g., a vehicle type may have 10 hours total time, and overtime starts from 8 hours.
             *
             * @default inf
             */
            overtime_start: number;
            /**
             * @description cost for this vehicle type to travel 1 unit distance when in overdistance.
             * @default 0
             */
            cost_per_unit_overdistance: number;
            /**
             * @description Specify when overdistance starts. e.g., a vehicle type incurs extra cost when travelling over 50 miles.
             *
             * @default inf
             */
            overdistance_start: number;
            /**
             * @description fixed cost to assign one vehicle with tasks.
             * @default 0
             */
            fixed_cost: number;
            /** @description Specify which cost metric from the `costs_by_metric` should be used for this vehicle type.
             *      */
            order_cost_metric?: string;
        };
        /** @description Vehicle for this route. */
        VehicleOnDemand: {
            /** @description User input descriptor for this vehicle. */
            id: string;
            /**
             * @description Routing profile for the vehicle. Default profiles are `[car, bicycle]`, you can also use a custom profile defined in `routing_profiles`
             * @default car
             */
            profile: string;
            /** @description Specify a speed factor for this vehicle (types). It will be applied to the distance matrix. Cannot be used together with `average_speed`.
             *      */
            speed_factor?: number;
            /** @description Specify an average speed for this vehicle (types). A speed factor will be derived and applied to the distance matrix. Cannot be used together with `speed_factor`.
             *      */
            average_speed?: number;
            /** @description Capacity of the vehicle. This property can also be specified in multiple dimensions (up to 4) with an array, such as weight, volume, and quantity. At least one dimension should be non-zero. */
            capacity?: number | number[];
            /**
             * @description Earliest time that this vehicle can be dispatched.
             * @default 0
             */
            dispatch_after: number;
            /**
             * @description Latest time that this vehicle must be dismissed.
             * @default inf
             */
            dismiss_before: number;
            /**
             * @description Parking time for this vehicle at order location.
             * @default 0
             */
            parking_time: number;
            /**
             * @description Maximum distance the vehicle can travel.
             * @default inf
             */
            max_distance: number;
            /**
             * @description Maximum duration the vehicle can travel for the workday.
             * @default inf
             */
            max_travel_time: number;
            /**
             * @description Maximum duration the vehicle can be on duty for the workday.
             * @default inf
             */
            max_total_time: number;
            /**
             * @description Maximum order time window violation the vehicle can have for the workday.
             * @default 0
             */
            max_late_time: number;
            /**
             * @description Maximum wait time allowed for a vehicle to wait before an order time window.
             * @default inf
             */
            max_wait_time: number;
            /** @description Maximum size of accumulated pickup for the workday. */
            max_pickup_quantities?: number | number[];
            /** @description Maximum size of accumulated dropoff for the workday. */
            max_dropoff_quantities?: number | number[];
            /**
             * @description Maximum number of orders the vehicle can service per trip. Orders at same location that set `merge_calc_for_colocated` to `true` will only be counted once for the calculation. `Warning: lifting this constraint will significantly affect the solver performance.`
             *
             * @default 100
             */
            max_orders_per_route: number;
            /**
             * @description Minimum number of orders the vehicle can service per trip. Orders at same location that set `merge_calc_for_colocated` to `true` will only be counted once for the calculation. Note this is a soft constraint, solver will try hard to respect this constraint if possible, however, total cost may increase.
             *
             * @default 0
             */
            min_orders_per_route: number;
            /**
             * @description Maximum number of pickup orders the vehicle can service per trip. Orders at same location that set `merge_calc_for_colocated` to `true` will only be counted once for the calculation.
             *
             * @default inf
             */
            max_pickup_orders_per_route: number;
            /**
             * @description Maximum number of dropoff orders the vehicle can service per trip. Orders at same location that set `merge_calc_for_colocated` to `true` will only be counted once for the calculation.
             *
             * @default inf
             */
            max_dropoff_orders_per_route: number;
            /**
             * @description Maximum number of waypoints the vehicle can visit per trip. Waypoint is defined as unique (lat, lon, timepoint), including orders, depots, and renewals.
             *
             * @default inf
             */
            max_waypoints_per_route: number;
            /**
             * @description When set to true, automatically merge all orders at same location for the vehicle's `cost_per_order` and `max_[pickup|dropoff]_orders_per_route` calculation. In other words, orders at the same location will only be counted once.
             *
             * @default false
             */
            merge_colocated_in_calc: boolean;
            /**
             * @description Try to avoid wait time at each stop. May increase total travel time and distance.
             * @default false
             */
            avoid_wait_time: boolean;
            /** @description Array of capabilities that vehicle has. */
            capabilities?: string[];
            /** @description Only assign orders inside the specified polygons to this vehicle type. */
            allowed_polygons?: string[];
            /** @description Only assign orders outside the specified polygons to this vehicle type. */
            disallowed_polygons?: string[];
            cost_params?: components["schemas"]["CostParamsOnDemand"];
        };
        SolverParamsOnDemand: {
            map_provider?: components["schemas"]["MapProviderNoHere"];
            /** @description Specify the time point in ISO 8601 format for traffic query. For example, `2021-01-01T14:00:00-08:00` means 2021 Jan 1st, 2PM, UTC-08:00. Not available when `map_provider` is set to `osm` (OpenStreetMap). Required when `map_provider` is set to `tomtom`. */
            traffic_time?: string;
            /** @description Specify the maximum distance to snap unroutable locations to nearest road network. */
            snap_distance?: number;
            /**
             * @description Specify search level for optimization, from 0 to 2, default to 1. Setting to 0 will greatly reduce solver time but make solution quality worse. Setting to 2 will improve solution quality at the cost of increasing solver time.
             *
             * @default 1
             */
            search_level: number;
            /** @default false */
            avoid_tolls: boolean;
            /**
             * @deprecated
             * @description ~~Further improve solution quality at the cost of increasing solver time.~~ This feature is deprecated, please use `search_level` instead.
             *
             * @default false
             */
            exhaustive_search: boolean;
            /** @description Capabilities are hard constraints by default. However, you can specify them here to be soft constraints, i.e., it can be dropped when no matching vehicle can be found.
             *      */
            soft_capabilities?: string[][];
        };
        ReplanRequest: {
            /** @description Specify current routes that's already planned. */
            current_routes: components["schemas"]["CurrentRoute"][];
            /**
             * @deprecated
             * @description ~~Specify customized routing profiles.~~ This feature is deprecated, please use `average_speed` or `speed_factor` in `current_routes.[].vehicle`.
             *
             */
            routing_profiles?: components["schemas"]["RoutingProfile"][];
            solver_parameters?: components["schemas"]["SolverParamsReplan"];
            units: components["schemas"]["Units"];
            /** @description Define array of tags associated with this requests, which will be returned as-is in response.
             *      */
            user_tags?: string[];
        };
        SolverParamsReplan: {
            map_provider?: components["schemas"]["MapProviderAllowHere"];
            /** @description Specify the time point in ISO 8601 format for traffic query. For example, `2021-01-01T14:00:00-08:00` means 2021 Jan 1st, 2PM, UTC-08:00. Not available when `map_provider` is set to `osm` (OpenStreetMap). Required when `map_provider` is set to `tomtom` or `here`. */
            traffic_time?: string;
            /** @description Specify the maximum distance to snap unroutable locations to nearest road network. */
            snap_distance?: number;
            /**
             * @description Specify search level for optimization, from 0 to 2, default to 1. Setting to 0 will greatly reduce solver time but make solution quality worse. Setting to 2 will improve solution quality at the cost of increasing solver time.
             *
             * @default 1
             */
            search_level: number;
            /** @default false */
            avoid_tolls: boolean;
            /**
             * @deprecated
             * @description ~~Further improve solution quality at the cost of increasing solver time.~~ This feature is deprecated, please use `search_level` instead.
             *
             * @default false
             */
            exhaustive_search: boolean;
        };
        RoutingRequest: {
            /** @description Specify sequence of waypoints. */
            locations: components["schemas"]["Geometry"][];
            parameters?: components["schemas"]["SolverParamsRouting"];
        };
        /** @description Parameters of Routing API. */
        SolverParamsRouting: {
            map_provider?: components["schemas"]["MapProviderNoHere"];
            /** @description Specify a routing profile from the list, `[bicycle, car]`. Default is `car`. */
            profile?: string;
            /** @description Specify the time point in ISO 8601 format for traffic query. For example, `2021-01-01T14:00:00-08:00` means 2021 Jan 1st, 2PM, UTC-08:00. Not available when `map_provider` is set to `osm` (OpenStreetMap). Required when `map_provider` is set to `tomtom`. */
            traffic_time?: string;
            /** @description Specify the maximum distance to snap unroutable locations to nearest road network. */
            snap_distance?: number;
            /**
             * @description Specify true to avoid toll roads.
             * @default false
             */
            avoid_tolls: boolean;
            /**
             * @description Specify number of alternative routes returned. Default is 0, which means only optimal route is returned. Actual number of routes returned may be fewer than specified number if it's larger than the service calculated.
             * @default 0
             */
            alternatives: number;
        };
        MatrixRoutingRequest: {
            /** @description Specify list of origins. */
            origins: components["schemas"]["Geometry"][];
            /** @description Specify list of destinations. */
            destinations?: components["schemas"]["Geometry"][];
            parameters?: components["schemas"]["SolverParamsMatrixRouting"];
        };
        /** @description Parameters of Matrix Routing API. */
        SolverParamsMatrixRouting: {
            map_provider?: components["schemas"]["MapProviderNoHere"];
            /** @description Specify a routing profile from the list, `[bicycle, car]`. Default is `car`. */
            profile?: string;
            /** @description Specify a speed factor for this routing profile. It will be applied to the distance matrix. Cannot be used together with `average_speed`.
             *      */
            speed_factor?: number;
            /** @description Specify an average speed for this routing profile. A speed factor will be derived and applied to the distance matrix. Cannot be used together with `speed_factor`.
             *      */
            average_speed?: number;
            /** @description Specify the time point in ISO 8601 format for traffic query. For example, `2021-01-01T14:00:00-08:00` means 2021 Jan 1st, 2PM, UTC-08:00. Not available when `map_provider` is set to `osm` (OpenStreetMap). Required when `map_provider` is set to `tomtom`. */
            traffic_time?: string;
            /** @description Specify the maximum distance to snap unroutable locations to nearest road network. */
            snap_distance?: number;
            /**
             * @description Specify true to avoid toll roads.
             * @default false
             */
            avoid_tolls: boolean;
        };
        MapMatchingRequest: {
            /** @description Specify list of GPS tracepoints. */
            waypoints: components["schemas"]["MapMatchingTracepoint"][];
            parameters?: components["schemas"]["SolverParamsMapMatching"];
        };
        MapMatchingTracepoint: {
            lat: number;
            lon: number;
            /**
             * @description Specifies the direction a vehicle may arrive at and depart from the order. If true, vehicle must stop at the closest curbside of this coordinate.
             *
             * @default false
             */
            curb: boolean;
            radius?: number;
            timestamp?: number;
        };
        /** @description Parameters of Map Matching API. */
        SolverParamsMapMatching: {
            map_provider?: components["schemas"]["MapProviderNoHere"];
            /** @description Specify a routing profile from the list, `[bicycle, car]`. Default is `car`. */
            profile?: string;
        };
        InProgressResponse: {
            /** @description ID assigned to this job, can be used to fetch the result. */
            job_id?: string;
            /**
             * @description status of this job
             * @enum {string}
             */
            status?: "IN_QUEUE" | "IN_PROGRESS";
            /** @description status message */
            message?: string;
            /** @description progress of the job, e.g., 50%. Note this field is optional and may be missing. */
            progress?: string;
        };
        FailedResponse400: {
            /** @description ID assigned to this job, can be used to fetch the result. */
            job_id?: string;
            /**
             * @description status of this job
             * @enum {string}
             */
            status?: "FAILED";
            /** @description error message */
            message?: string;
            /** @description array of failed reasons */
            reasons?: string[];
            details?: components["schemas"]["ViolationDetails"];
            /** @description array of warnings */
            warnings?: string[];
        };
        FailedResponse5xx: {
            /** @description ID assigned to this job, can be used to fetch the result. */
            job_id?: string;
            /**
             * @description status of this job
             * @enum {string}
             */
            status?: "FAILED";
            /** @description error message */
            message?: string;
        };
        OptimizationResponse: {
            /** @description ID assigned to this job, can be used to fetch the result. */
            job_id?: string;
            /**
             * @description status of this job
             * @enum {string}
             */
            status?: "SUCCEED";
            /** @description Time elapsed in route optimization in seconds. */
            solver_time?: string;
            plan_summary?: components["schemas"]["OptimizationSummary"];
            routes?: components["schemas"]["Route"][];
            /** @description List of unassigned orders. */
            unassigned?: components["schemas"]["UnassignedStop"][];
            units?: components["schemas"]["Units"];
            user_tags?: string[];
            /** @description List of warnings found. */
            warnings?: string[];
        };
        OptimizationSummary: {
            distance?: number;
            total_time?: number;
            travel_time?: number;
            wait_time?: number;
            late_time?: number;
            service_time?: number;
            num_routes?: number;
            unassigned?: number;
            assigned?: number;
            assigned_pairs?: number;
            average_speed?: string;
            total_cost?: number;
        };
        Route: {
            summary?: components["schemas"]["RouteSummary"];
            stops?: components["schemas"]["RouteStop"][];
        };
        RouteSummary: {
            /** @description Travel distance in user defined unit */
            distance?: number;
            /** @description Total time span for this trip, including travel time, wait time, break time, and service time etc. */
            total_time?: number;
            /** @description Travel time is driving duration. */
            travel_time?: number;
            service_time?: number;
            begin_time?: number;
            end_time?: number;
            wait_time?: number;
            late_time?: number;
            pickup_quantity?: number;
            dropoff_quantity?: number;
            paired_pickup_quantity?: number;
            paired_delivery_quantity?: number;
            capacity_utilization?: number;
            num_breaks?: number;
            num_orders?: number;
            num_waypoints?: number;
            vehicle_id?: string;
            route_id?: number;
            profile?: string;
            total_cost?: number;
        };
        RouteStop: {
            id?: string;
            position?: number;
            arrival_time?: number;
            wait_time?: number;
            service_time?: number;
            late_time?: number;
            depart_time?: number;
            current_load?: number;
            /** @enum {string} */
            type?: "order" | "start_depot" | "end_depot" | "break";
            paired_stop?: string;
            geometry?: {
                lon?: number;
                lat?: number;
                zipcode?: string;
                curb?: boolean;
            };
        };
        UnassignedStop: {
            /** @description ID of this unassigned order. */
            id?: string;
            /** @description Human-readable reasons of this unassigned order, separated by semicolon. */
            reason?: string;
            details?: components["schemas"]["ViolationDetails"];
        };
        /** @description List of details for this unassigned order.
         *      */
        ViolationDetails: [
            number,
            string,
            string
        ][];
        RoutingResponse: {
            /** @enum {string} */
            status?: "SUCCEED";
            /** @description List of routes found. */
            routes?: components["schemas"]["RoutingResponseRoute"][];
            /** @description List of waypoints snapped to road network from input locations. */
            waypoints?: components["schemas"]["RoutingResponseWaypoint"][];
        };
        RoutingResponseRoute: {
            /** @description A polyline representation of this route. */
            geometry?: string;
            /** @description Total distance (in meters) of the route. */
            distance?: number;
            /** @description Total duration (in seconds) of the route. */
            duration?: number;
            /** @description List of routes between waypoints. */
            legs?: components["schemas"]["RoutingResponseRouteLeg"][];
        };
        RoutingResponseRouteLeg: {
            /** @description Distance (in meters) between an adjacent waypoints. */
            distance?: number;
            /** @description Duration (in seconds) between an adjacent waypoints. */
            duration?: number;
        };
        RoutingResponseWaypoint: {
            /** @description Distance (in meters) between the input and snapped coordinate. */
            distance?: number;
            /** @description Name of the street the input coordinate snapped to. */
            name?: string;
            /** @description Snapped coordinate of the input coordinate. */
            location?: {
                lat?: number;
                lon?: number;
            };
        };
        MatrixRoutingResponseJSON: {
            /** @enum {string} */
            status?: "SUCCEED";
            num_origins?: number;
            num_destinations?: number;
            /** @description List of estimated travel time in seconds (row major order). Negative numbers indicate an error, -1 means no route can be found, -2 means location is too far from the road network and cannot be snapped.
             *      */
            durations?: number[];
            /** @description List of estimated distance in meters (row major order). Negative numbers indicate an error, -1 means no route can be found, -2 means location is too far from the road network and cannot be snapped. */
            distances?: number[];
        };
        /**
         * Format: binary
         * @description Matrix Routing API result in binary format. The values are stored as 4-byte integers using little-endian representation. Each matrix element consists of two integers: distance and duration (in meters and seconds). For example, a 3x3 matrix would result in 72 bytes, as it comprises 9 elements, with each element occupying 8 bytes: a 4-byte integer for duration, followed by a 4-byte integer for distance. Negative numbers indicate errors, where a value of -1 means no route can be found between the two locations. And -2 means a location is too far from the road network, possibly due to user input error or missing map data.
         *
         */
        MatrixRoutingResponseBinary: string;
        MapMatchingResponse: {
            /** @description List of routes that assemble the tracepoints provided. */
            matchings?: components["schemas"]["MapMatchingResponseMatch"][];
            /** @description List of tracepoints matched in order. */
            trace_points?: components["schemas"]["MapMatchingResponseTrace"][];
        };
        MapMatchingResponseMatch: {
            /** @description Confidence of the match, bigger means more confident */
            confidence?: number;
            /** @description A polyline representation of this route. */
            geometry?: string;
            /** @description Total distance (in meters) of the route. */
            distance?: number;
            /** @description Total duration (in seconds) of the route. */
            duration?: number;
            legs?: components["schemas"]["RoutingResponseRouteLeg"][];
        };
        MapMatchingResponseTrace: {
            /** @description Index of the route in the matchings array. */
            matchings_index?: number;
            /** @description Index of the waypoint in current matched route. */
            waypoint_index?: number;
            /** @description Distance (in meters) between the input and snapped coordinate. */
            distance?: number;
            /** @description Name of the street the input coordinate snapped to. */
            name?: string;
            /** @description Snapped coordinate of the input coordinate. */
            location?: {
                lat?: number;
                lon?: number;
            };
        };
    };
    responses: {
        /** @description Job has been accepted. */
        Response202: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["InProgressResponse"];
            };
        };
        /** @description Missing or invalid API key */
        Response401: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    message?: string;
                };
            };
        };
        /** @description User does not have access to the API */
        Response403: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    message?: string;
                };
            };
        };
        /** @description Job ID does not exist */
        Response404: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    message?: string;
                };
            };
        };
        /** @description Request validation failed */
        Response422: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    message?: string;
                    /** @description array of failed reasons */
                    reasons?: string[];
                };
            };
        };
        /** @description Job failed due to unexpected server error */
        Response500: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FailedResponse5xx"];
            };
        };
        /** @description Job failed due to bad response from backend server */
        Response502: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FailedResponse5xx"];
            };
        };
        /** @description Job failed due to backend server timeout */
        Response504: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FailedResponse5xx"];
            };
        };
        /** @description Job has finished successfully */
        Response200Optimization: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["OptimizationResponse"];
            };
        };
        /** @description Job failed due to client error */
        Response400Optimization: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["FailedResponse400"];
            };
        };
        /** @description Request finished successfully */
        Response200Routing: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["RoutingResponse"];
            };
        };
        /** @description Request finished successfully */
        Response200MatrixRouting: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MatrixRoutingResponseJSON"];
                "application/octet-stream": components["schemas"]["MatrixRoutingResponseBinary"];
            };
        };
        /** @description Request finished successfully */
        Response303MatrixRouting: {
            headers: {
                /** @description 303 redirect URL for the result. */
                location?: string;
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @description URL to download the Matrix Routing API result in binary format, see explanation in POST Matrix Routing API 200 response.
                     *      */
                    download_url?: string;
                };
            };
        };
        /** @description Request finished successfully */
        Response200MapMatching: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["MapMatchingResponse"];
            };
        };
    };
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    vrp_result: {
        parameters: {
            query: {
                /** @description Job ID returned by `/vrp` POST. */
                job_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Response200Optimization"];
            202: components["responses"]["Response202"];
            400: components["responses"]["Response400Optimization"];
            401: components["responses"]["Response401"];
            403: components["responses"]["Response403"];
            404: components["responses"]["Response404"];
            422: components["responses"]["Response422"];
            500: components["responses"]["Response500"];
            502: components["responses"]["Response502"];
            504: components["responses"]["Response504"];
        };
    };
    vrp: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description VRP problem to be solved */
        requestBody: {
            content: {
                "application/json": components["schemas"]["VrpRequest"];
            };
        };
        responses: {
            200: components["responses"]["Response200Optimization"];
            202: components["responses"]["Response202"];
            400: components["responses"]["Response400Optimization"];
            401: components["responses"]["Response401"];
            403: components["responses"]["Response403"];
            422: components["responses"]["Response422"];
            500: components["responses"]["Response500"];
            502: components["responses"]["Response502"];
            504: components["responses"]["Response504"];
        };
    };
    tsp_result: {
        parameters: {
            query: {
                /** @description Job ID returned by `/tsp` POST. */
                job_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Response200Optimization"];
            202: components["responses"]["Response202"];
            400: components["responses"]["Response400Optimization"];
            401: components["responses"]["Response401"];
            403: components["responses"]["Response403"];
            404: components["responses"]["Response404"];
            422: components["responses"]["Response422"];
            500: components["responses"]["Response500"];
            502: components["responses"]["Response502"];
            504: components["responses"]["Response504"];
        };
    };
    tsp: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description TSP problem to be solved */
        requestBody: {
            content: {
                "application/json": components["schemas"]["TspRequest"];
            };
        };
        responses: {
            200: components["responses"]["Response200Optimization"];
            202: components["responses"]["Response202"];
            400: components["responses"]["Response400Optimization"];
            401: components["responses"]["Response401"];
            403: components["responses"]["Response403"];
            422: components["responses"]["Response422"];
            500: components["responses"]["Response500"];
            502: components["responses"]["Response502"];
            504: components["responses"]["Response504"];
        };
    };
    ondemand_result: {
        parameters: {
            query: {
                /** @description Job ID returned by `/ondemand` POST. */
                job_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Response200Optimization"];
            202: components["responses"]["Response202"];
            400: components["responses"]["Response400Optimization"];
            401: components["responses"]["Response401"];
            403: components["responses"]["Response403"];
            404: components["responses"]["Response404"];
            422: components["responses"]["Response422"];
            500: components["responses"]["Response500"];
            502: components["responses"]["Response502"];
            504: components["responses"]["Response504"];
        };
    };
    ondemand: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description On-demand routing problem to be solved */
        requestBody: {
            content: {
                "application/json": components["schemas"]["OnDemandRequest"];
            };
        };
        responses: {
            200: components["responses"]["Response200Optimization"];
            202: components["responses"]["Response202"];
            400: components["responses"]["Response400Optimization"];
            401: components["responses"]["Response401"];
            403: components["responses"]["Response403"];
            422: components["responses"]["Response422"];
            500: components["responses"]["Response500"];
            502: components["responses"]["Response502"];
            504: components["responses"]["Response504"];
        };
    };
    replan_result: {
        parameters: {
            query: {
                /** @description Job ID returned by `/replan` POST. */
                job_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: components["responses"]["Response200Optimization"];
            202: components["responses"]["Response202"];
            400: components["responses"]["Response400Optimization"];
            401: components["responses"]["Response401"];
            403: components["responses"]["Response403"];
            404: components["responses"]["Response404"];
            422: components["responses"]["Response422"];
            500: components["responses"]["Response500"];
            502: components["responses"]["Response502"];
            504: components["responses"]["Response504"];
        };
    };
    replan: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Current route plan to be re-optimized. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ReplanRequest"];
            };
        };
        responses: {
            200: components["responses"]["Response200Optimization"];
            202: components["responses"]["Response202"];
            400: components["responses"]["Response400Optimization"];
            401: components["responses"]["Response401"];
            403: components["responses"]["Response403"];
            422: components["responses"]["Response422"];
            500: components["responses"]["Response500"];
            502: components["responses"]["Response502"];
            504: components["responses"]["Response504"];
        };
    };
    route: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Sequence of waypoints to calculate route. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["RoutingRequest"];
            };
        };
        responses: {
            200: components["responses"]["Response200Routing"];
            401: components["responses"]["Response401"];
            403: components["responses"]["Response403"];
            422: components["responses"]["Response422"];
            500: components["responses"]["Response500"];
            502: components["responses"]["Response502"];
            504: components["responses"]["Response504"];
        };
    };
    matrix_result: {
        parameters: {
            query: {
                /** @description Job ID returned by `/matrix` POST. */
                job_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            202: components["responses"]["Response202"];
            303: components["responses"]["Response303MatrixRouting"];
            401: components["responses"]["Response401"];
            403: components["responses"]["Response403"];
            404: components["responses"]["Response404"];
            422: components["responses"]["Response422"];
            500: components["responses"]["Response500"];
            502: components["responses"]["Response502"];
            504: components["responses"]["Response504"];
        };
    };
    matrix: {
        parameters: {
            query?: never;
            header?: {
                /** @description By default, Matrix Routing API returns result in JSON format. Alternatively, you can specify `application/octet-stream` in the `accept` HTTP header to request binary format, which might be preferred when you need faster parsing and smaller memory usage.
                 *      */
                accept?: "application/octet-stream" | "application/json";
            };
            path?: never;
            cookie?: never;
        };
        /** @description List of locations to calculate travel distances and durations. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MatrixRoutingRequest"];
            };
        };
        responses: {
            200: components["responses"]["Response200MatrixRouting"];
            202: components["responses"]["Response202"];
            401: components["responses"]["Response401"];
            403: components["responses"]["Response403"];
            422: components["responses"]["Response422"];
            500: components["responses"]["Response500"];
            502: components["responses"]["Response502"];
            504: components["responses"]["Response504"];
        };
    };
    match: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description List of GPS tracepoints to calculate route. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MapMatchingRequest"];
            };
        };
        responses: {
            200: components["responses"]["Response200MapMatching"];
            401: components["responses"]["Response401"];
            403: components["responses"]["Response403"];
            422: components["responses"]["Response422"];
            500: components["responses"]["Response500"];
            502: components["responses"]["Response502"];
            504: components["responses"]["Response504"];
        };
    };
}
